'use strict';import{AssertionError,AttributeError,BaseException,DeprecationWarning,Exception,IndexError,IterableError,KeyError,NotImplementedError,RuntimeWarning,StopIteration,UserWarning,ValueError,Warning,__JsIterator__,__PyIterator__,__Terminal__,__add__,__and__,__call__,__class__,__envir__,__eq__,__floordiv__,__ge__,__get__,__getcm__,__getitem__,__getslice__,__getsm__,__gt__,__i__,__iadd__,__iand__,__idiv__,__ijsmod__,__ilshift__,__imatmul__,__imod__,__imul__,__in__,__init__,__ior__,__ipow__,
__irshift__,__isub__,__ixor__,__jsUsePyNext__,__jsmod__,__k__,__kwargtrans__,__le__,__lshift__,__lt__,__matmul__,__mergefields__,__mergekwargtrans__,__mod__,__mul__,__ne__,__neg__,__nest__,__or__,__pow__,__pragma__,__pyUseJsNext__,__rshift__,__setitem__,__setproperty__,__setslice__,__sort__,__specialattrib__,__sub__,__super__,__t__,__terminal__,__truediv__,__withblock__,__xor__,abs,all,any,assert,bool,bytearray,bytes,callable,chr,copy,deepcopy,delattr,dict,dir,divmod,enumerate,filter,float,getattr,
hasattr,input,int,isinstance,issubclass,len,list,map,max,min,object,ord,pow,print,property,py_TypeError,py_iter,py_metatype,py_next,py_reversed,py_typeof,range,repr,round,set,setattr,sorted,str,sum,tuple,zip}from"./org.transcrypt.__runtime__.js";var __name__="code";export var source="\n<pre><code class=\"language-python\">\n#Draw Pad\n\nplatform = None\n# __pragma__ ('skip')\nimport os\nif os.name in ('posix', 'nt', 'os2', 'ce', 'riscos'):\n  import pygame as pg\n  platform = 'pc'\nelif os.name == 'java':\n  import pyj2d as pg\n  platform = 'jvm'\nelse:\n  import pyjsdl as pg\n  platform = 'js'\n# __pragma__ ('noskip')\nif platform is None:\n  import pyjsdl as pg\n  from pyjsdl.pylib import os\n  platform = 'js'\n\n\nclass Canvas(object):\n\n  def __init__(self, display):\n    self.display = display\n    self.width, self.height = self.display.get_size()\n    self.display.fill((238,238,238))\n    self.pad = pg.Surface((self.width, self.height))\n    self.pad.fill((238,238,238))\n    self.pad_area = self.display.get_rect()\n    self.update_rects = []\n    self.edges = self.set_edges()\n    self.colors = ((243,139,160), (173,194,169),\n                   (167,197,235), (238,238,238))\n    self.color_index = 0\n    self.color = self.colors[0]\n    self.set_palette_control()\n    self.set_reset_control()\n    self.brushes = pg.sprite.RenderUpdates()\n    self.brush = Brush(self)\n    self.brushes.add(self.brush)\n    self.update_rects.append(self.pad_area)\n    if platform == 'js':\n      handler = TouchHandler(self)\n      pg.env.event.touchlistener.add_callback(handler)\n    if platform == 'pc' and hasattr(pg, 'WINDOWCLOSE'):\n      self.windowclose = pg.WINDOWCLOSE\n    else:\n      self.windowclose = 0\n    self.clock = pg.time.Clock()\n\n  def set_edges(self):\n    w, h = self.width, self.height\n    edges = []\n    for rect in [(0,0,20,h), (w-20,0,20,h-20),\n                 (0,0,w,20), (0,h-20,w,20)]:\n      edge_rect = pg.Rect(rect)\n      edges.append(edge_rect)\n      pg.draw.rect(self.pad, (108,115,126), edge_rect, 0)\n    self.display.blit(self.pad, (0,0))\n    return edges\n\n  def set_palette_control(self):\n    self.palette = pg.Surface((18, 18))\n    self.palette.fill(self.color)\n    pg.draw.rect(self.palette, (0,0,0), (0,0,18,18), 1)\n    self.pad.blit(self.palette, (1, self.height-19))\n    self.palette_area = self.display.blit(self.palette,\n                                (1, self.height-19))\n    self.update_rects.append(self.palette_area)\n\n  def set_reset_control(self):\n    self.reset = pg.Surface((18, 18))\n    self.reset.fill((108,115,126))\n    pg.draw.rect(self.reset, (0,0,0), (0,0,18,18), 1)\n    self.pad.blit(self.reset, (self.width-19, self.height-19))\n    self.reset_area = self.display.blit(self.reset,\n                              (self.width-19, self.height-19))\n    self.update_rects.append(self.reset_area)\n\n  def draw_edges(self):\n    for edge_rect in self.edges:\n      pg.draw.rect(self.pad, (108,115,126), edge_rect, 0)\n\n  def draw_palette_control(self):\n    self.pad.blit(self.palette, (1, self.height-19))\n\n  def draw_reset_control(self):\n    self.pad.blit(self.reset, (self.width-19, self.height-19))\n\n  def reset_pad(self):\n    self.display.fill((238,238,238))\n    self.pad.fill((238,238,238))\n    self.set_edges()\n    self.set_palette_control()\n    self.set_reset_control()\n    self.update_rects.append(self.pad_area)\n\n  def set_brush(self):\n    self.brush.set_brush()\n\n  def check_input(self):\n    quit = False\n    for evt in pg.event.get():\n      if evt.type == pg.MOUSEBUTTONDOWN and evt.button == 1:\n        if self.palette_area.collidepoint(evt.pos):\n          self.color_index += 1\n          if self.color_index > 3:\n            self.color_index = 0\n          self.color = self.colors[self.color_index]\n          self.brush.color = self.color\n          self.set_palette_control()\n        elif self.reset_area.collidepoint(evt.pos):\n          self.reset_pad()\n        else:\n          self.brush.paint = True\n      elif evt.type == pg.MOUSEBUTTONUP:\n        self.brush.paint = False\n        self.brush.pre_pos.update(-1.0, -1.0)\n      elif evt.type == pg.ACTIVEEVENT:\n        if evt.state == 2:\n          self.update_rects.append(self.pad_area)\n      elif evt.type == pg.KEYDOWN:\n        if evt.key == pg.K_ESCAPE:\n          quit = True\n      elif evt.type in (pg.QUIT, self.windowclose):\n        quit = True\n      return quit\n\n  def update(self):\n    self.brushes.update()\n    if self.brush.paint:\n      self.draw_edges()\n      self.draw_palette_control()\n      self.draw_reset_control()\n      for rect in self.brush.strokes:\n        self.display.blit(self.pad, (rect.x,rect.y), rect)\n      self.update_rects.extend(self.brush.strokes)\n    self.brushes.clear(self.display, self.pad)\n    rects = self.brushes.draw(self.display)\n    self.update_rects.extend(rects)\n    pg.display.update(self.update_rects)\n    self.update_rects[:] = []\n    self.clock.tick(60)\n\n\nclass Brush(pg.sprite.Sprite):\n\n  def __init__(self, canvas):\n    pg.sprite.Sprite.__init__(self)\n    self.canvas = canvas\n    self.width, self.height = 60, 60\n    self.radius = self.width // 10\n    if platform == 'pc':\n      image = os.path.join('data', 'brush.png')\n      self.image = pg.image.load(image)\n    else:\n      self.image = pg.image.load('./data/brush.png')\n    self.rect = self.image.get_rect()\n    self.offset = (25,-20)\n    self.position = pg.Vector2(0.0,0.0)\n    self.pre_pos = pg.Vector2(-1.0,-1.0)\n    self.positions = []\n    self.strokes = []\n    self.color = self.canvas.color\n    self.paint = False\n\n  def set_brush(self):\n    self.image = pg.Surface((14,14))\n    pg.draw.circle(self.image, (108,115,126,75), (7,7), 6, 1)\n    self.rect = self.image.get_rect()\n    self.offset = (0,0)\n\n  def draw(self):\n    self.strokes[:] = []\n    self.positions[:] = []\n    if (self.position != self.pre_pos and\n      self.pre_pos.x != -1):\n      distance = self.position.distance_to(self.pre_pos)\n      if distance > (self.radius/4.0):\n        pos_num = int(distance / (self.radius/4.0))\n        for t in [float(i)/pos_num for i in range(pos_num)]:\n          pos = self.pre_pos.lerp(self.position, t)\n          self.positions.append((int(pos.x), int(pos.y)))\n    else:\n      self.positions.append((int(self.position.x),\n                             int(self.position.y)))\n    for pos in self.positions:\n      rect = pg.draw.circle(self.canvas.pad, self.color,\n                           (pos[0], pos[1]), self.radius)\n      self.strokes.append(rect)\n    self.pre_pos.update(self.position.x, self.position.y)\n\n  def update(self):\n    position = pg.mouse.get_pos()\n    if not self.canvas.pad_area.collidepoint(position):\n      if self.paint:\n        self.paint = False\n    self.position.update(position[0], position[1])\n    self.rect.center = (self.position.x+self.offset[0],\n                        self.position.y+self.offset[1])\n    if self.paint:\n      self.draw()\n\n\nclass TouchHandler(object):\n\n  def __init__(self, canvas):\n    self.canvas = canvas\n\n  def onTouchInitiate(self, event):\n    self.canvas.set_brush()\n\n  def onTouchStart(self, event):\n    touch = event.touches.item(0)\n    r = pg.env.canvas.getElement().getBoundingClientRect()\n    x = touch.clientX-round(r.left)\n    y = touch.clientY-round(r.top)\n    evt = pg.event.Event(pg.MOUSEBUTTONDOWN,\n                 {'button':1, 'pos':(x,y), 'event':event})\n    pg.event.post(evt)\n    pg.event.mouseMove['x'] = touch.clientX\n    pg.event.mouseMove['y'] = touch.clientY\n    if event.cancelable:\n      event.preventDefault()\n\n  def onTouchEnd(self, event):\n    r = pg.env.canvas.getElement().getBoundingClientRect()\n    x = pg.event.mouseMove['x']-round(r.left)\n    y = pg.event.mouseMove['y']-round(r.top)\n    evt = pg.event.Event(pg.MOUSEBUTTONUP,\n                 {'button':1, 'pos':(x,y), 'event':event})\n    pg.event.post(evt)\n    if event.cancelable:\n      event.preventDefault()\n\n  def onTouchMove(self, event):\n    touch = event.touches.item(0)\n    pg.event.mouseMove['x'] = touch.clientX\n    pg.event.mouseMove['y'] = touch.clientY\n\n  def onTouchCancel(self, event):\n    pass\n\n\nclass App(object):\n\n  def __init__(self, display):\n    self.canvas = Canvas(display)\n    self.quit = False\n  \n  def run(self):\n    self.quit = self.canvas.check_input()\n    self.canvas.update()\n\n\ndisplay = None\n\n\ndef setup():\n  global display\n  pg.init()\n  display = pg.display.set_mode((500, 400))\n  pg.display.set_caption('Draw Pad')\n  if platform != 'js':\n    icon = pg.image.load(os.path.join('data', 'pad.png'))\n    pg.display.set_icon(icon)\n  pg.event.set_blocked(pg.MOUSEMOTION)\n  pg.mouse.set_cursor((8,8),(0,0),\n                      (0,0,0,0,0,0,0,0),(0,0,0,0,0,0,0,0))\n\n\ndef main():\n  setup()\n  app = App(display)\n  while True:\n    if app.quit:\n      break\n    app.run()\n\n\ndef run_js():\n  app = App(display)\n  pg.set_callback(app)\n\n\ndef main_js():\n  setup()\n  pg.setup(run_js, ['./data/brush.png'])\n\n\nif __name__ == '__main__':\n  if platform in ('pc', 'jvm'):\n    main()\n  elif platform == 'js':\n    main_js()\n</code></pre>\n";

//# sourceMappingURL=code.map