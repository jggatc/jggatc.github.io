'use strict';import{AssertionError,AttributeError,BaseException,DeprecationWarning,Exception,IndexError,IterableError,KeyError,NotImplementedError,RuntimeWarning,StopIteration,UserWarning,ValueError,Warning,__JsIterator__,__PyIterator__,__Terminal__,__add__,__and__,__call__,__class__,__envir__,__eq__,__floordiv__,__ge__,__get__,__getcm__,__getitem__,__getslice__,__getsm__,__gt__,__i__,__iadd__,__iand__,__idiv__,__ijsmod__,__ilshift__,__imatmul__,__imod__,__imul__,__in__,__init__,__ior__,__ipow__,
__irshift__,__isub__,__ixor__,__jsUsePyNext__,__jsmod__,__k__,__kwargtrans__,__le__,__lshift__,__lt__,__matmul__,__mergefields__,__mergekwargtrans__,__mod__,__mul__,__ne__,__neg__,__nest__,__or__,__pow__,__pragma__,__pyUseJsNext__,__rshift__,__setitem__,__setproperty__,__setslice__,__sort__,__specialattrib__,__sub__,__super__,__t__,__terminal__,__truediv__,__withblock__,__xor__,_sort,abs,all,any,assert,bin,bool,bytearray,bytes,callable,chr,delattr,dict,dir,divmod,enumerate,filter,float,getattr,hasattr,
hex,input,isinstance,issubclass,len,list,map,max,min,object,oct,ord,pow,print,property,py_TypeError,py_iter,py_metatype,py_next,py_reversed,py_typeof,range,repr,round,set,setattr,sorted,str,sum,tuple,zip}from"./org.transcrypt.__runtime__.js";import{int}from"./pyjsdl.pylib.js";import{Color}from"./pyjsdl.color.js";import{BitSet}from"./pyjsdl.pyjsarray.js";var __name__="pyjsdl.mask";export var __docformat__="restructuredtext";export var from_surface=function(surface,threshold){if(typeof threshold=="undefined"||
threshold!=null&&threshold.hasOwnProperty("__kwargtrans__"))var threshold=127;var mask=Mask(tuple([surface.width,surface.height]));if(!mask.bit)return null;var imagedata=surface.getImageData(0,0,surface.width,surface.height);var data=imagedata.data;var __left0__=tuple([surface.width*4,surface.height]);var width=__left0__[0];var height=__left0__[1];for(var y=0;y<height;y++){var xpix=0;var i=y*width+3;var bitset=mask.bit[y];var bit=bitset._bit;var _data=bitset._data;for(var x=0;x<width;x+=4){if(data[i+
x]>threshold){var index=~~(xpix/bit);_data[index]=_data[index]|bitset._bitmask[__mod__(xpix,bit)]}xpix++}}return mask};export var from_threshold=function(surface,color,threshold){if(typeof threshold=="undefined"||threshold!=null&&threshold.hasOwnProperty("__kwargtrans__"))var threshold=tuple([0,0,0,255]);var mask=Mask(tuple([surface.width,surface.height]));if(!mask.bit)return null;var imagedata=surface.getImageData(0,0,surface.width,surface.height);var data=imagedata.data;if(threshold==tuple([0,0,
0,255])){var color=Color(color);var __left0__=tuple([surface.width*4,surface.height]);var width=__left0__[0];var height=__left0__[1];for(var y=0;y<height;y++){var xpix=0;var i=y*width;var bitset=mask.bit[y];var bit=bitset._bit;var _data=bitset._data;for(var x=0;x<width;x+=4){var ix=i+x;if(data[ix]==color.r&&data[ix+1]==color.g&&data[ix+2]==color.b&&data[ix+3]>=threshold[3]){var index=~~(xpix/bit);_data[index]=_data[index]|bitset._bitmask[__mod__(xpix,bit)]}xpix++}}}else{var color=Color(color);var col=
dict({});col["r1"]=color.r-threshold[0]-1;col["r2"]=color.r+threshold[0]+1;col["g1"]=color.g-threshold[1]-1;col["g2"]=color.g+threshold[1]+1;col["b1"]=color.b-threshold[2]-1;col["b2"]=color.b+threshold[2]+1;col["a"]=threshold[3]-1;var __left0__=tuple([surface.width*4,surface.height]);var width=__left0__[0];var height=__left0__[1];for(var y=0;y<height;y++){var xpix=0;var i=y*width;var bitset=mask.bit[y];var bit=bitset._bit;var _data=bitset._data;for(var x=0;x<width;x+=4){var ix=i+x;if(col["r1"]<data[ix]&&
data[ix]<col["r2"]&&(col["g1"]<data[ix+1]&&data[ix+1]<col["g2"])&&(col["b1"]<data[ix+2]&&data[ix+2]<col["b2"])&&data[ix+3]>col["a"]){var index=~~(xpix/bit);_data[index]=_data[index]|bitset._bitmask[__mod__(xpix,bit)]}xpix++}}}return mask};export var Mask=__class__("Mask",[object],{__module__:__name__,get __init__(){return __get__(this,function(self,size){self.width=int(size[0]);self.height=int(size[1]);self.bit=[];for(var bitset=0;bitset<self.height;bitset++)self.bit.append(BitSet(self.width))})},
get __str__(){return __get__(this,function(self){return self.toString()})},get __repr__(){return __get__(this,function(self){return"{}({})".format(self.__class__,repr(self.__dict__))})},get get_size(){return __get__(this,function(self){return tuple([self.width,self.height])})},get get_at(){return __get__(this,function(self,pos){return self.bit[pos[1]].py_get(pos[0])})},get set_at(){return __get__(this,function(self,pos,value){if(typeof value=="undefined"||value!=null&&value.hasOwnProperty("__kwargtrans__"))var value=
1;self.bit[pos[1]].set(pos[0],value);return null})},get fill(){return __get__(this,function(self){for(var bitset of self.bit)bitset.fill();return null})},get py_clear(){return __get__(this,function(self){for(var bitset of self.bit)bitset.py_clear();return null})},get invert(){return __get__(this,function(self){for(var bitset of self.bit)bitset.flip(0,self.width);return null})},get count(){return __get__(this,function(self){var true_bits=0;for(var bitset of self.bit)true_bits+=bitset.cardinality();
return true_bits})},get overlap(){return __get__(this,function(self,mask,offset){if(offset[0]>0){var x1=offset[0];var x2=0}else{var x1=0;var x2=-offset[0]}if(offset[1]>0){var y1=offset[1];var y2=0}else{var y1=0;var y2=-offset[1]}var w=min(self.width-x1,mask.width-x2);var h=min(self.height-y1,mask.height-y2);if(w>0&&h>0)for(var y=0;y<h;y++)if(self.bit[y1+y].py_get(x1,x1+w).intersects(mask.bit[y2+y].py_get(x2,x2+w)))return true;return null})},get toString(){return __get__(this,function(self,bit){if(typeof bit==
"undefined"||bit!=null&&bit.hasOwnProperty("__kwargtrans__"))var bit=tuple(["1","0"]);var cbit=dict({true:bit[0],false:bit[1]});var cbitset=[];for(var bitset of self.bit){cbitset.append("\n");cbitset.extend(function(){var __accu0__=[];for(var i=0;i<self.width;i++)__accu0__.append(cbit[bitset.py_get(i)]);return __accu0__}())}var bitstr="".join(cbitset);return bitstr})}});export var _overlap=function(mask1,mask2,offset){if(offset[0]>0){var x1=offset[0];var x2=0}else{var x1=0;var x2=-offset[0]}if(offset[1]>
0){var y1=offset[1];var y2=0}else{var y1=0;var y2=-offset[1]}var w=min(mask1.width-x1,mask2.width-x2);var h=min(mask1.height-y1,mask2.height-y2);if(w>0&&h>0)for(var y=0;y<h;y++){var bitset1=mask1.bit[y1+y];var bitset2=mask2.bit[y2+y];var _bitset1=_bitset_get(bitset1,x1,x1+w);var _bitset2=_bitset_get(bitset2,x2,x2+w);var intersect=_intersects(_bitset1,_bitset2);_bitsetPool_set(_bitset1);_bitsetPool_set(_bitset2);if(intersect)return true}return false};export var _intersects=function(bitset1,bitset2){for(var dat=
0;dat<bitset1._data.length;dat++){var data1=bitset1._data;var data2=bitset2._data;var intersect=data1[dat]&data2[dat];if(intersect)return true}return false};export var _bitset_get=function(bitset,index,toIndex){var data=bitset._data;var _bitset=_bitsetPool_get(toIndex-index);var ix=0;if(toIndex>bitset._width)var toIndex=bitset._width;for(var i=index;i<toIndex;i++){_bitset_set(_bitset,ix,bool(data[int(i/bitset._bit)]&bitset._bitmask[__mod__(i,bitset._bit)]));ix++}return _bitset};export var _bitset_set=
function(bitset,index,value){var data=bitset._data;if(value)data[int(index/bitset._bit)]=data[int(index/bitset._bit)]|bitset._bitmask[__mod__(index,bitset._bit)];else data[int(index/bitset._bit)]=data[int(index/bitset._bit)]&~bitset._bitmask[__mod__(index,bitset._bit)]};export var _bitsetPool=dict({});export var _bitsetPool_get=function(size){if(!__in__(size,_bitsetPool))_bitsetPool[size]=[];if(len(_bitsetPool[size])>0)var bitset=_bitsetPool[size].py_pop();else var bitset=BitSet(size);return bitset};
export var _bitsetPool_set=function(bitset){var data=bitset._data;for(var i=0;i<data.length;i++)data[i]=0;_bitsetPool[bitset._width].append(bitset)};

//# sourceMappingURL=pyjsdl.mask.map